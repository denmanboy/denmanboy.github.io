---
title: c语言学习笔记
toc: true
tags: c语言
categories: technology
date: 2011-04-10 18:16:58
description: c语言学习整理
---
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  
<script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  
<script>hljs.initHighlightingOnLoad();</script>

在64位操作系统    int 占 4字节 long 8字节  short 2字节  
在32位操作系统   int  占 4字节  long 4字节  short 2字节  
变量声明的同时进行赋值  
int height  = 180; //在开辟空间的同时 ，把180 放到内存中<br>
float 占4字节  double 占 8位  
printf ("%lu",sizeof(1.123)); // 计算常需要多大空间存放 常量是没有空间的   
在浮点型 数据常量后一般要加f  规范   
float f = 1,123f;  
float类型 小数点前和 小数点后 位数 最多写 6 --  7 位 否则  不再准确  
double 的有效数字位数 是15 -16 位  
（小数点前和小数点后总共 不能超过 15--16位）  
两个整数相处 结果还是整数 如果有求出有小数那么 小数点后面全部舍去。   
强制类型转换  printf ("%f\n", (double ) b/a); (double ) b/a ；强制类型转换  把变量b中的值的类型临时强转为double 类型  
强制 类型转换不会改变 变量 b的类型 强制转的是变量b中值的类型（临时强转）  
表达式 ：有标识符或数字或者运算符构成的式子  
a++ 表达式的值就是a 自增 1 之前使用 a的值  先使用a的值 再自增  a++  的值 就是 加前使用a的值  
++a  也是一个表达式 ，表达式的值就是a自增1之后a的值；然后把++a的值给c  
++a 的值就是加后使用a的值  
自增和自减 经常会应用于 计数器 循环  
自增自减两侧只能是变量  
表达式就是一个值 值就是常量  
关系表达式  ：如果表达式成立  表达式为真 那么 表达式的值就是1 如果表达式不成立 表达式 为假 表达式的值就是0    
关系表达式 经常应用于 if 结构 和循环结构中  
0为假 非零 即为真   && 逻辑与  
xcode  优先级时  直接加 小括号  规范写法  
如果逻辑与表达式中的第一个表达式是假 那么第二个表达式将不再运算  
如果逻辑或表达式中的第一个表达式是真 那么第二个表达式将不再运算  
逗号表达式 //表达式1，表达式2，表达式3，….表达式n;  
逗号表达式的值是最后一个表达式的值 逗号表达式是从左 向右依次进行运算的。  
条件运算符  ： 表达式1 ？表达式2 ：表达式3；  
问号 冒号表达式的值是：如果表达式1成立，那么 运算表达式2，最后总的表达式的的值就是表达式2的值 ，  否则运算表达式3，总表达式的值就是表达是3的值  
问号  冒号表达式 可以求两个数的较大一个的值，函数也是一个表达式 函数名字就是标识符，括号内就是运算   
函数调用就是一个表达式    
 隐式装换 ：不同数据类型之间进行运算时，会出现隐式装换   
整型向浮点型看齐  
短字节向长字节看齐  
float向 double看齐  
有符号向无符号看齐  


c语言中 % 是占位符  
类型   占位符              类型           占位符   
int        %d        unsigned   int     %u   
long    %ld        unsigned long     %lu  
short   %hd      unsigned short    %hu    
最大值 +1 会发生溢出 变成最小值 物极必反  
字符存到计算机中存到是字符的ASCII码值  
声明一个变量，如果没给赋值那么就是一个随机值。  
函数是一个可以是实现一个 具体功能的代码块   
屏幕缓冲区 遇到 换行符 把缓冲区的 内容打印到屏幕上  
scanf  函数中不能加换行符号     

 char 类型就是整型数据  
   
函数的分类   
1. 库函数  
2.自定义函数(程序员自己实现的函数)  
3.函数的三要素  返回值 函数名 参数  
  
  main函数 是自定义函数 main函数自己写代码 去实现   
  形参就是变量声明 不能在函数{}内再声明一个相同的变量名了，否则重复定义   
  局部变量 的使用范围只能在包含变量的{} 中从 声明开始到{}结束使用 大括号 就是限制变量的作用域的
 			遇到return之后就会返回调用这个函数的地方 return之后的语句不会执行
 			
 函数传参 就是把实参赋给形参  什么时候写参数 当我们 需要从函数外部传到函数内部数据时我们就可以写带参数的函数，传一个写一个参数，传两个数据那么写两个参数',' 分割<br>

只要函数有返回值类型 那么函数实现过程中必须要return一个值<br>
 scanf （）接收double 类型的数据时 要用 %lf 接收  printf () 中用%f输出 <br>
函数调用就是调用一个表达式 <br>
函数调用了才会执行里面的代码<br>

函数的作用<br>
函数使我们的程序清楚明白<br>

函数使用之前先定义   通过函数调用来使用 类似上下级管理形式<br>
调用时指定函数名字所需要的信息 （参数）<br>
调用完成后向 老板报告的工作 递交报告<br>
函数返回值最多一个<br>
表达式就是一个值 表达式成立就是 1  不成立就是0<br>
关系表达式 返回值 不是1就是 0<br>
%02d   表示 数字占两位。如果不够两位 那么补0；<br>
变量初始化时没赋给初值，那么变量的值是随机的<br>
for 循环的第二个表达式可以省去 表示无线循环 （死循环）<br>
在循环嵌套中，break 只能跳出一层 循环 <br>
c=getchar  ()  从键盘接收一个字符 赋值给  c，等价于<br>
scanf（"%c",&c）;1既不是质数也不是合数<br>
do--while  先执行do{}中的语句块内容 然后再去判断表达式是否成立 do{}中的语句至少 执行依次 <br>
scanf（“%d”） 遇到非数字字符 停止接收<br> 
%-2d 表示占两位 左对齐 %2d 表示 占两位 右对齐<br>
case 语句中声明变量必须要加一个 {}<br>
形参的本质就是变量声明<br>
只有调用函数才会压栈<br>
代码段就是一个工作流程<br>
首先编译代码之后，会把代码
编译成 二进制可执行文件 运行<br>
二进制可执行程序：首先cpu会把二进制代码 放到内存的代码段（我们写的代码都在这个二进制文件中），然后cpu就会去读代码段中 二进制文件的内容，首先会调用main函数，这个时候就会在栈段压一个main 栈 （main函数 中的数据就会 在main栈中）<br>
变量的周期   开辟空间到 释放空间<br>
变量的 范围就是包含这个变量声明的{}内（从声明开始）<br>
在函数外声明的变量 就是全局变量 一般写在头文件的下方 <br>
全局变量不初始化 默认为零 全局变量的作用域 ：整个工程所有的文件都可以使用<br>
全部 变量在内存 不会 伴随栈的消失而消失 数据段 程序结才会释放空间<br>
数据段和栈段是两个独立内存区域<br>
数据段生命周期  程序结束才会结束<br>
静态的局部变量是放在数据段<br>
静态局部变量作用域（包含他的{}内使用 ）内存布局：数据段 生命周期：程序结束 static int cnt=1;//这句代码只是在编译的时候只执行了一次 其他时候不会执行<br>
c语言很少用到static <br>
数组名表示数组的空间大小 int a[5];    sizeof( int a[5])==20;<br>
大小用多少字节来表示<br>
只有初始化数组的时候数组的元算个数可以省去<br>
初始化了几个元素那么这个数组的元素总个数就是多少个<br>
int a[5]={}; //对数组的每个元素清零 以后我们只要<br>
声明数组必须要初始化 如果没有特定的值进行初始化  那么就必须清零 <br>
数组不能整体赋值 因为数组名是一个常量 数组名就是数组的第一个 元素空间的地址<br>
依次对数组的每一个元素进行赋值<br>

数组名代表数组占的空间大小 a[];    sizeof( a)可以求出数组所有元素所占空间的大小；<br>
int *  是一个整体 是一个复合类型 ， 表示 指针运算符<br>
指针变量 只能存放地址常量<br>
int* 就是指针变量类型<br>
指针变量就是存放空间的地址的<br>
空间地址类型 ：空间的类型 加 *<br>
在64位系统下 所有的指针类型都是占8字节<br>
一个字节 一个地址<br>
内存以字节为单位 <br>
打印变量的空间地址 或者 指针变量 用%p  %p就是用十六进制显示门牌号 第一个 字节作为整体的门牌号
*pInt 含义分两步（寻址操作）程序员可以寻址<br>

1.	找到pint 中存放的<br>
2.	门牌号的位置<br>
3.	从门牌号开始取空间的大小<br>
4.	当一个变量两侧出现两个运算符 比如 *（指针运算符）++ -- [] ! & 这是采用右结合 但是以后 出现类似的 表达式 我们尽量加上<br>


如果一个函数内部要修改另外一个函数的变量 那么只要获取<br>
另外一个函数 里的变量的地址就可以了<br>
指针可以跨栈引用 <br>
int m;<br>
scanf("%d",&m);//因为 scanf 函数内部要修改main函数中变量m （跨函数修改变量）所以必须要传m的地址<br>
free（p）释放指针变量p 释放后 p 不能再使用<br>
野指针 结果不可预测<br>
使用scanf时必须要传 一个合法空间的地址<br>
只要使用变量必须 把一个合法的空间地址赋给指针变量 <br>
指针变量必须要指向合法的空间<br>
只要使用指针变量一定要给这个指针变量赋一个合法的空间地址<br>

strcmp(s1,s2) 字符串比较函数<br>
依次比较s1和s2 指向的字符串中 对应字符ascii 值 当两个对应的字符 ascii相等 那么继续比较 ，直到遇到不相等的结束比较返回 <br>

*p 就是一个表达式 * 后面跟的是一个地址 指针运算符后面必须是一个地址类型<br>
指针不能进行乘除运算 可以 和整数进行 加减运算<br>
相同的指针类型 之间 只可以进行减法运算,可以得到步长<br>
\#if       #end if 可以注释 之间的内容<br>
地址类型 和整型 相加 向地址类型看齐<br>
数组名就是数组第一个元素的地址<br>
c语言 规定数组名就是数组的首元素地址 是一个常量 不能自增<br>
以后 只要想通过 一个函数操作函数外面的数组 那么就必须传数组的第一个元素的地址<br>
printfArray( int p[5],int n) //是不规范的写法 初学者不要这样写 （这是编译器的妥协 允许这样写 实际上编译器会把这里的int p[5] 转化为 int*     p ，传的是数组的首地址）<br>
const  int* p=&a;//const 限制*p不能改 （在下面代码中 不能出现 对*p这个 式子赋值）p没有限制 可以改<br>
const int *p 和 int const *p 称为*前const<br>
int * const  m=&a;// const 限制的是指针变 m不能改    ，      *m可以改
int const * const n=&a;
两个const 限制 n和*n n和*n都不能改
函数名字就是一个地址 就是函数在代码段中的地址
函数指针 可以存储 函数的地址 就是函数名地址
int （*p）（int ，int）=add; //p是一个指针，是一个函数指针，这个 指针指向 一个具有两个int 类型的参数 和一个int 类型的返回值的函数 p <br>
知道函数的地址就可以操作函数   调用函数<br>
参数是一个函数指针 <br>
 int a[5]规定&a就是数组整个空间的地址<br>
int (*)[5]  数组 a整个空间的地址 类型 <br>
&a +1 是加1个整个数组空间大小<br>
a和 &a数值大小一样但是只有类型不一样<br>

p 是是一个指针变量p[0]就等于*（p +0）<br>
int * 数组空间的地址类型 <br>
int （*）[ 5] 数组的a整个空间地址的类型<br>
除了字符串常量以外的常量没有空间<br>
字符串常量在只读数据段(只读数据段只能读不能写)<br>
字符串常量以 尾零'\0' 结束 '\0'的ASCCI 的值是0 就是null<br>
“\0”是字符串 0 里面有两个字符 一个是字符‘0’一个是尾零‘\0’<br>
%s 打印一个字符串用%s执行过程 <br>
传入的地址开始逐个打印字符 直到遇到‘\0’<br>
scanf("%s",buff); 接收字符串 可以用%s 把接收的字符串放入字符数组中 %s以空格和‘\n’作为分隔条件 %s 不能接收空格<br>
str 功能：统计字符串的有效字符个数 遇到‘\0’结束统计 （不统计‘\0’）<br>
数组不能整体赋值 数组名是常量<br>
预处理语句：以#开头  在预处理阶段展开
头文件
#include 在预处理阶段 把头文件导入到代码中 
宏名  一般要大写<br>
宏名 要满足标示符  宏定义语句 必须要在同一行<br>
宏 ：就是代码 替换  宏名就是代表后面一串字符<br>
宏 ： 一改全改   不检查类型<br>
有参宏 #define  ADD(a+b) a+b<br>
宏也可以传参数 没有类型<br>
带参数的宏 宏名中不能 有空格<br>
定义带参数的宏 代替的内容 中参数 和整体都要加（）<br>
‘\’表示连接符 在预处理阶段 会把下面的代码 链接成一行<br> 
条件编译 预处理语句 <br>
在预处理阶段 若果为真 那么保留语句块<br>

	#if 值 
	语句块
	#end if


条件编译必须以endif结束<br>
条件编译 是解决包含多次头文件<br>
结构体 最后面 必须以 分号结束<br>

对结构体初始化 必须完全初始化<br>
结构体 可以整体赋值 <br>
不建议 一句话声明俩个变量<br>
枚举的功能就是增强代码的额可读性
通配型指针 就是可以赋给任意类型的指<br>针 或者任意类型的指针可以赋值给通配型指针<br>
*p 是通配型 指针<br>
*p=1；通配型 指针不能取* 因为取*之后 不知道取多大空间<br>
堆空间 没有名字 匿名空间 所以我们只能通过堆空间的地址来操作 堆空间<br>
用 malloc申请 堆空间<br>
malloc（4）——>>> 申请4字节的堆空间<br>
堆空间使用完 之后要释放<br>
free（pInt）；释放pInt指向的堆空间 释放之后 pInt指向的堆空间 就不能在使用了<br>
堆空间只有手动调用free 函数才能释放 或者程序结束<br>
堆空间 不会伴随栈释放而是释放<br>















